var createProxyHandler = function(protocol, hostname, port, pathPrefix)
{
    const proxy = require("http2-proxy");
    const finalhandler = require('finalhandler')
    
    const defaultWebHandler = function(err, req, res) {
        if (err)
        {
            console.log("A web proxy error was caught, path: " + req.path + ", err: ", err);
            try { res.status(500); } catch (e) { }
            try { res.end('Something went wrong while proxying the request.'); } catch (e) { }
        }
        
        finalhandler(req, res)(err);
    };
    
    // web
    var webConfig = {};
    webConfig.hostname = hostname;
    webConfig.port = port;
    webConfig.protocol = protocol;
    //webConfig.path = null;
    webConfig.timeout = 120000;
    webConfig.proxyTimeout = 120000;
    webConfig.proxyName = "Cloud CMS UI Proxy";
    webConfig.onReq = function(req, options) {
        
        if (!options.headers) {
            options.headers = {};
        }
        var headers = options.headers;
        
        if (options.path && options.path.startsWith("/proxy")) {
            options.path = options.path.substring(6);
        }
        
        if (pathPrefix) {
            options.path = path.join(pathPrefix, options.path);
        }
        
        // used to auto-assign the client header for /oauth/token requests
        //oauth2.autoProxy(req);
        
        // copy domain host into "x-cloudcms-domainhost"
        if (req.domainHost) {
            headers["x-cloudcms-domainhost"] = req.domainHost; // this could be "localhost"
        }
        
        // copy virtual host into "x-cloudcms-virtualhost"
        if (req.virtualHost) {
            headers["x-cloudcms-virtualhost"] = req.virtualHost; // this could be "root.cloudcms.net" or "abc.cloudcms.net"
        }
        
        // copy deployment descriptor info
        if (req.descriptor)
        {
            if (req.descriptor.tenant)
            {
                if (req.descriptor.tenant.id)
                {
                    headers["x-cloudcms-tenant-id"] = req.descriptor.tenant.id;
                }
                
                if (req.descriptor.tenant.title)
                {
                    headers["x-cloudcms-tenant-title"] = req.descriptor.tenant.title;
                }
            }
            
            if (req.descriptor.application)
            {
                if (req.descriptor.application.id)
                {
                    headers["x-cloudcms-application-id"] = req.descriptor.application.id;
                }
                
                if (req.descriptor.application.title)
                {
                    headers["x-cloudcms-application-title"] = req.descriptor.application.title;
                }
            }
        }
        
        // set optional "x-cloudcms-origin" header
        var cloudcmsOrigin = null;
        if (req.virtualHost)
        {
            cloudcmsOrigin = req.virtualHost;
        }
        if (cloudcmsOrigin)
        {
            headers["x-cloudcms-origin"] = cloudcmsOrigin;
        }
        
        // set x-cloudcms-server-version header
        //headers["x-cloudcms-server-version"] = process.env.CLOUDCMS_APPSERVER_PACKAGE_VERSION;
        
        // keep alive
        //req.headers["connection"] = "keep-alive";
        
        // if the incoming request didn't have an "Authorization" header
        // and we have a logged in Gitana User via Auth, then set authorization header to Bearer Access Token
        if (!req.headers["authorization"])
        {
            if (req.gitana_user)
            {
                headers["authorization"] = "Bearer " + req.gitana_user.getDriver().http.accessToken();
            }
            else if (req.gitana_proxy_access_token)
            {
                headers["authorization"] = "Bearer " + req.gitana_proxy_access_token;
            }
        }
    };
    webConfig.onRes = function(req, res, proxyRes) {
        
        // if (req.gitana_user)
        // {
        //     var chunks = [];
        //
        //     // triggers on data receive
        //     proxyRes.on('data', function(chunk) {
        //         // add received chunk to chunks array
        //         chunks.push(chunk);
        //     });
        //
        //     proxyRes.on("end", function () {
        //
        //         if (proxyRes.statusCode === 401)
        //         {
        //             var text = "" + Buffer.concat(chunks);
        //             if (text && (text.indexOf("invalid_token") > -1) || (text.indexOf("invalid_grant") > -1))
        //             {
        //                 var identifier = req.identity_properties.provider_id + "/" + req.identity_properties.user_identifier;
        //
        //                 _LOCK([identifier], function(err, releaseLockFn) {
        //
        //                     if (err)
        //                     {
        //                         // failed to acquire lock
        //                         console.log("FAILED TO ACQUIRE LOCK", err);
        //                         req.log("FAILED TO ACQUIRE LOCK", err);
        //                         try { releaseLockFn(); } catch (e) { }
        //                         return;
        //                     }
        //
        //                     var cleanup = function (full)
        //                     {
        //                         delete Gitana.APPS[req.identity_properties.token];
        //                         delete Gitana.PLATFORM_CACHE[req.identity_properties.token];
        //
        //                         if (full) {
        //                             auth.removeUserCacheEntry(identifier);
        //                         }
        //                     };
        //
        //                     // null out the access token
        //                     // this will force the refresh token to be used to get a new one on the next request
        //                     req.gitana_user.getDriver().http.refresh(function (err) {
        //
        //                         if (err) {
        //                             cleanup(true);
        //                             req.log("Invalidated auth state for gitana user: " + req.identity_properties.token);
        //                             return releaseLockFn();
        //                         }
        //
        //                         req.gitana_user.getDriver().reloadAuthInfo(function () {
        //                             cleanup(true);
        //                             req.log("Refreshed token for gitana user: " + req.identity_properties.token);
        //                             releaseLockFn();
        //                         });
        //                     });
        //                 });
        //             }
        //
        //         }
        //     });
        // }
        
        //res.setHeader('x-powered-by', 'cloudcms');
        res.writeHead(proxyRes.statusCode, proxyRes.headers)
        proxyRes.pipe(res)
    };
    
    var proxyRequestHandler = function(req, res) {
        proxy.web(req, res, webConfig, function(err, req, res) {
            defaultWebHandler(err, req, res);
        });
    };
    
    return proxyRequestHandler;
};

const http = require("http");
const server = http.createServer()
server.listen(3000);

var proxyRequestHandler = createProxyHandler("http", "api.default.svc.cluster.local", 80);
server.on('request', (req, res) => {
    req.virtualHost = "mt85.us1.cloudcms.net";
    
    proxyRequestHandler(req, res);
});
